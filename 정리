go는 내가 원하는 로컬의 위치에 프로젝트를 넣을 수 없다.

정해진 위치(mac인 경우 /users/{userID}/go 밑에) 위치해야한다.

---------------------------------------------------------

go는 main이 있어야만 컴파일을 한다.

main이 없는 파일들은 대부분 모두가 같이 쓰기 위해 만들어지는 프로젝트이다.

-----------------------------------------------------------

fucction을 export하고 싶으면 go는 대문자로 시작하게 하면된다.

소문자로 함수이름을 작성하면 저절로 private으로 지정되어서 다른(import가 되는)곳에서는 사용할 수 없게 된다.

------------------------------------------------------------------------

go에서 상수를 만들때는 const를 사용해서 만들면 된다.

name := "nico"와 var name string = "nico" 는 같은 의미 이다.
전자와 같이 쓰면 go가 타입을 찾아준다.

func 밖에서 변수 작성시에는
var name string = "nico" 이런식으로만 작성을해야 된다. 위의 예의 전자와 같이 작성하면 안된다.
-> 축약형은 func에서만 가능하다.

-----------------------------------------------------------------------------

go는 다른 언어들과 다르게 하나의 함수의 multiple 리턴이 가능하다.
여러개의 리턴값을 받을때 _ 이런식으로 값을 무시하는방법을 사용하면 원하는 값만 리턴 받을 수 있다.
...string과 같은 인자값에 대한 문법을 사용하면 여러 값을 한번에 받아서 배열로 리턴해줄 수 있다.

-------------------------------------------------------------------------------

naked return 이란 
func lenAndUpper(name string) (length int, upppercase string) {
	length = len(name)
	upppercase = strings.ToUpper(name)
	return
}
이런식으로 리턴값에 변수명을 줘서 변수명에 대한 것들을 재정의 하면 go가 저절로 return을 맞춰준다.


defer 이란
func이 끝났을때, 추가적으로 무엇인가 동작하도록 할 수 있다.
뭔가를 확실히 끝냈다는것을 확인 할 수 있으므로 디버깅에 아주 효과적이다.

--------------------------------------------------------------------

go의 loop(반복문)는 오로지 for만 사용하는것으로 한다.

range라는 단어는 array에 loop를 적용할 수 있도록 해준다.
range는 index를 줄 수 있다.

----------------------------------------------------

if문 이나 if else 문에서 조건문 뒤에 바로 새로운 변수에대한값을 생성하는 방법을 쓸 수 있다.(variable extenstion)
switch문도 같다.

---------------------------------------------------------

slice는 go에서 배열의 길이가 없이 사용되는 array 이다.
go는 append를 사용해서 배열에 값을 추가를 하는데, 기본적으로 배열의 원값을 바꾸는게 아니고 새로운값을 만들어서 리턴해준다.

---------------------------------------------------------------

go의 map은 map[string]string => [key]value 	형태로 이루어진다.

------------------------------------------------------------------

go에는 constructor(생성자)가 없어서 따로 실행을 시켜줘야한다.

------------------------------------------------------

변수명이나 func명도 똑같이 대문자면 public 소문자면 private로 정의 된다.

------------------------------------------------------

go에는 exception을 처리하는 try catch throw 같은건 없다. error를 직접 체크해야한다.

-------------------------------------------------------------------- 

GO에서 최적화하는 방법은 동시에 작업을 처리하는 것 -> 함수를 불러올떄 go라는 keyword를 달아주면 비동기식 처리로 바뀐다.
메인함수안에 모든 함수가 go 처리가 되어있으면 그냥 끝나버린다 -> go처리는 다른 함수가 진행될떄 같이 진행 되는 개념이므로 모든 함수가 go를 가지게 되면 메인 함수 안에서 진행되는 함수가 없기 때문에 그냥 끝난다.

--------------------------------------------------------------------

channel 은 pipe 같은 것 
위의 설명에 main에 모든 함수에 go 처리가 되어있으면, 메인이 바로 종료되는것을 방지할 수 있게, channel을 사용하는 방법이 있다.(sleep을 사용하여 기다리게 한후)

----------------------------------------------------------------

메세지를 받는 건(<-c) blocking operation(channel을 이용해서)
남아있는 goroutin이 없는데 채널값을 받으려고 하면 데드락현상이 발생한다(go는 저절로 goroutin이 몇개인지 확인 할 수 있다.)

-----------------------------------------------------------------

함수의 받는 인자에 c chan<- result 이런식으로 처리하면 보내는 채널만 가능하고 받는 채널은 불가능하다는 의미이다.




